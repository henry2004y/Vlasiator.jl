<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Track waves · Vlasiator.jl</title><meta name="title" content="Track waves · Vlasiator.jl"/><meta property="og:title" content="Track waves · Vlasiator.jl"/><meta property="twitter:title" content="Track waves · Vlasiator.jl"/><meta name="description" content="Documentation for Vlasiator.jl."/><meta property="og:description" content="Documentation for Vlasiator.jl."/><meta property="twitter:description" content="Documentation for Vlasiator.jl."/><meta property="og:url" content="https://henry2004y.github.io/Vlasiator.jl/examples/postprocess/demo_wave_tracing_mt/"/><meta property="twitter:url" content="https://henry2004y.github.io/Vlasiator.jl/examples/postprocess/demo_wave_tracing_mt/"/><link rel="canonical" href="https://henry2004y.github.io/Vlasiator.jl/examples/postprocess/demo_wave_tracing_mt/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Vlasiator.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../manual/">User Guide</a></li><li><a class="tocitem" href="../../">Examples</a></li><li><a class="tocitem" href="../../../python/">Calling from Python</a></li><li><a class="tocitem" href="../../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../../benchmark/">Benchmarks</a></li><li><a class="tocitem" href="../../../internal/">API Reference</a></li><li><a class="tocitem" href="../../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../../log/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Track waves</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Track waves</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/henry2004y/Vlasiator.jl/blob/master/docs/examples/postprocess/demo_wave_tracing_mt.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="demo_track_waves"><a class="docs-heading-anchor" href="#demo_track_waves">Track waves</a><a id="demo_track_waves-1"></a><a class="docs-heading-anchor-permalink" href="#demo_track_waves" title="Permalink"></a></h1><p><a href="https://github.com/henry2004y"><img src="https://img.shields.io/badge/Author-Hongyang%20Zhou-blue" alt="Author"/></a> <img src="https://img.shields.io/date/1677283200" alt="Update time"/></p><p>This demo shows how to track wave and plot the dispersion relation On a equatorial plane, B ∥ ẑ, we can choose an arbitrary line in-plane. On a meridional plane, B is in-plane, we can find a local line region ∥ B and ⟂ B.</p><p>Currently it only works on a equatorial plane.</p><p>Usage:</p><pre><code class="language-shell hljs">julia -t 4 demo_wave_tracing_mt.jl</code></pre><p>or</p><pre><code class="language-shell hljs">JULIA_NUM_THREADS=4 julia demo_wave_tracing_mt.jl</code></pre><pre><code class="language-julia hljs">using Vlasiator, VlasiatorPyPlot
using Vlasiator: qᵢ, μ₀, c, mᵢ, ϵ₀, RE
using Glob, DSP, FFTW, ImageFiltering, Interpolations
using Statistics: mean
using LinearAlgebra

## Types

struct Variables
   varnames::Vector{String}
   varnames_print::Vector{String}
   components::Vector{Int}
end

## Methods

ispolar(meta::MetaVLSV) = findfirst(==(1), meta.ncells) == 2

&quot;Extract `component` of variable `varname` at `cellids` from `files`.&quot;
function extract_var(files, varname, cellids, distances, component=0)
   sample_loc = range(distances[1], distances[end], length=length(distances))

   var = zeros(length(distances), length(files))

   Threads.@threads for i in eachindex(files)
      meta = load(files[i])
      if component == 0
         var_line = readvariable(meta, varname, cellids)[:]
      else
         var_line = readvariable(meta, varname, cellids)[component,:]
      end
      #TODO: do we need high order interpolations?
      interp_linear = LinearInterpolation(distances, var_line)
      var_line_resample = interp_linear.(sample_loc)
      var_line_smooth = imfilter(var_line_resample, Kernel.gaussian((3,)))

      var[:,i] = var_line_smooth
   end
   var
end

&quot;CFL constrained normalized frequency.&quot;
dispersion_CFL(k, dx, dt, di, ωci) = dx/dt * abs(k) /(di * ωci)

&quot;Normalized frequency of fast magnetosonic waves along angle `θ` with Doppler shift.&quot;
function dispersion_fast_perp(k, θ, vS, vA, v, di, ωci)
   ω = zeros(length(k))

   turnindex = findfirst(&gt;=(0), k)

   vbulkpar = v[1]*cos(θ) + v[2]*sin(θ)

   dv1 =  √(vS^2 + vA^2) + vbulkpar # propagate along +θ direction
   dv2 = -√(vS^2 + vA^2) + vbulkpar # propagate along -θ direction

   if dv1 &lt; 0; dv1 = 0.0; end
   if dv2 &gt; 0; dv2 = 0.0; end

   for i in 1:turnindex-1
      ω[i] = dv2*k[i] /(di * ωci)
   end

   for i in turnindex:length(k)
      ω[i] = dv1*k[i] /(di * ωci)
   end
   ω
end

&quot;Normalized frequency of bulk flow along tilted angle `θ`.&quot;
function dispersion_bulk_flow(k, θ, v, di, ωci)
   ω = zeros(length(k))
   turnindex = findfirst(&gt;=(0), k)
   vbulkpar = v[1]*cos(θ) + v[2]*sin(θ)
   irange = vbulkpar &gt; 0 ? (turnindex:length(k)) : (1:turnindex)
   for i in irange # otherwise 0
      ω[i] = vbulkpar*k[i] /(di * ωci)
   end
   ω
end

&quot;Return the index in sorted `vec` with value closest to `x`.&quot;
function searchsortednearest(vec, x)
   idx = searchsortedfirst(vec, x)
   if idx == 1
      return idx
   elseif idx &gt; length(vec)
      return length(vec)
   elseif vec[idx] == x
      return idx
   elseif abs(vec[idx]-x) &lt; abs(vec[idx-1]-x)
      return idx
   else
      return idx-1
   end
end

&quot;Obtain fast mode and bulk speed along line `angle` w.r.t. x-axis for cell ID `cid` in
`meta`.&quot;
function getCharacteristicSpeeds(meta, cid, angle)
   n = readvariable(meta, &quot;proton/vg_rho&quot;, cid)
   B = readvariable(meta, &quot;vg_b_vol&quot;, cid)
   p = readvariable(meta, &quot;vg_pressure&quot;, cid)
   v = readvariable(meta, &quot;proton/vg_v&quot;, cid)

   Bmag = norm.(eachcol(B))

   vA  = @. Bmag / √(μ₀ * n * mᵢ)        # Alfven speed, [m/s]
   vS  = @. √(γ * p / (n * mᵢ))          # sonic speed, [m/s]

   vFast = @. √(vA^2 + vS^2)
   vBulk = @. v[1,:]*cos(angle) + v[2,:]*sin(angle)

   vFast, vBulk
end

&quot;Trace along line with `angle` w.r.t. x-axis at possible wave speeds.&quot;
function tracewave(xstart, angle, files, dtfile, t, cellids, distances)

   x1 = zeros(length(t)); x1[1] = xstart
   x2 = copy(x1)
   x3 = copy(x1)

   tfile = let
      tfilefirst = getproperty(load(files[1]), :time)
      tfilelast = getproperty(load(files[end]), :time)
      tfilefirst:dtfile:tfilelast
   end

   ifile = 1 # file index tracker

   dt = t[2] - t[1] # timestep

   for it in eachindex(t)[1:end-1]
      # Find the closest output saving time to t[it], 0th order interpolation
      for i = ifile:length(tfile)
         if abs(tfile[i] - t[it]) &lt; 0.5*dtfile
            ifile = i
            break
         end
      end
      meta = load(files[ifile])
      # Find the closest cell to the wave location
      cid = let
         c1 = searchsortednearest(distances, x1[it])
         c2 = searchsortednearest(distances, x2[it])
         c3 = searchsortednearest(distances, x3[it])
         cellids[c1], cellids[c2], cellids[c3]
      end
      vFast, vBulk = getCharacteristicSpeeds(meta, cid, angle)
      x1[it+1] = x1[it] + dt * vBulk[1]
      x2[it+1] = x2[it] + dt * (vBulk[2] + vFast[2])
      x3[it+1] = x3[it] + dt * (vBulk[3] - vFast[3])
   end

   x1, x2, x3
end

&quot;Evaluate the average quantities at `cellids` at the middle of `files`.&quot;
function estimate_meanstates(files, cellids)
   # Select the snapshot in the middle
   nfile = length(files)
   meta = load(files[nfile÷2+1])

   n = readvariable(meta, &quot;proton/vg_rho&quot;, cellids)
   v = readvariable(meta, &quot;proton/vg_v&quot;, cellids)
   p = readvariable(meta, &quot;vg_pressure&quot;, cellids)

   if hasvariable(meta, &quot;vg_b_vol&quot;)
      B = readvariable(meta, &quot;vg_b_vol&quot;, cellids)
   elseif hasvariable(meta, &quot;fg_b&quot;)
      B = readvariable(meta, &quot;fg_b&quot;, cellids)
   else
      B = readvariable(meta, &quot;b&quot;, cellids)
   end

   vperp = @view v[1:2,:]
   vpar = @view v[3,:]

   # Obtain average states
   n̄ = mean(n)
   p̄ = mean(p)
   v̄par = mean(vpar)
   v̄perp = @views [mean(vperp[1,:]), mean(vperp[2,:])]

   # Characteristic parameters
   Bnorm = @views abs(mean(B[3,:]))
   di  = √(mᵢ*ϵ₀/(n̄))*c/qᵢ               # ion inertial length, [m]
   ωci = qᵢ*Bnorm/mᵢ                     # [/s]
   v̄A  = Bnorm / √(μ₀ * n̄ * mᵢ)          # Alfven speed, [m/s]
   v̄S  = √(γ * p̄ / (n̄ * mᵢ))             # sonic speed, [m/s]

   println(&quot;--------------------------------------------------&quot;)
   println(&quot;* Average states along the line at the middle snapshot&quot;)
   println(&quot;Density               : &quot;, rpad(round(n̄/1e6; digits=2), 8), &quot;amu/cc&quot;)
   println(&quot;Pressure              : &quot;, rpad(round(p̄*1e9; digits=3), 8), &quot;nPa&quot;)
   println(&quot;Parallel velocity     : &quot;, rpad(round(v̄par/1e3; digits=2), 8), &quot;km/s&quot;)
   println(&quot;Perpendicular velocity: &quot;, rpad(round.(v̄perp/1e3; digits=2), 8), &quot;km/s&quot;)
   println(&quot;Flow angle            : &quot;, rpad(round(atand(v̄perp[2], v̄perp[1]); digits=2), 8),
      &quot;degrees&quot;)
   println(&quot;Ion inertial length   : &quot;, rpad(round(di/1e3; digits=2), 8), &quot;km&quot;)
   println(&quot;Gyrofrequency         : &quot;, rpad(round(ωci; digits=2), 8), &quot;Hz&quot;)
   println(&quot;Alfven speed          : &quot;, rpad(round(v̄A/1e3; digits=2), 8), &quot;km/s&quot;)
   println(&quot;Sonic speed           : &quot;, rpad(round(v̄S/1e3; digits=2), 8), &quot;km/s&quot;)
   println(&quot;--------------------------------------------------&quot;)

   di, ωci, v̄A, v̄S, v̄perp
end

&quot;Plot the process of wave checks.&quot;
function plot_dispersion(files, vars, cellids, distances, coords, meanstates, dtfile, Δt,
   outdir)

   # Parameters
   nfile = length(files)
   npoints = length(cellids)
   nt = nfile ÷ 2 + 1

   varnames = vars.varnames
   varnames_print = vars.varnames_print
   components = vars.components

   di, ωci, v̄A, v̄S, v̄perp = meanstates

   tfile1st = load(files[1]).time
   # Output timestamps
   t = [dtfile * ifile + tfile1st for ifile in 0:nfile-1]
   # Selected line tilted angle ∈ [-π, π]
   θ = atan(coords[2,end] - coords[2,1], coords[1,end] - coords[1,1])
   # Sample width, [m]
   dx = norm(coords[:,end] .- coords[:,1]) /(npoints - 1)
   println(&quot;spatial resolution: &quot;, round(dx/1e3; digits=2), &quot; km&quot;)

   # Trace wave along the line in a space-time domain
   twave = let
      tstart = 400.0
      tend = 430.0
      tstart:200Δt:tend
   end
   xwave = tracewave(distances[npoints÷2+1], θ, files, dtfile, twave, cellids, distances)

   twave2 = let
      tstart = 600.0
      tend = 630.0
      tstart:200Δt:tend
   end
   xwave2 = tracewave(distances[npoints÷2+1], θ, files, dtfile, twave2, cellids, distances)

   # Dispersion plotting ranges
   kmin = -π / dx * di         # minimum wave number
   kmax =  π / dx * di         # maximum wave number
   ωmin = 0                    # minimum angular frequency
   ωmax = π / dtfile / ωci     # maximum angular frequency

   # Only the 1st quadrature
   krange = range(kmin, kmax, length=npoints)
   ωrange = range(ωmin, ωmax, length=nt)

   axisunit = EARTH

   # Precalculated lines
   ωCFL = dispersion_CFL.(krange, dx, Δt, di, ωci)
   ωfast = dispersion_fast_perp(krange, θ, v̄S, v̄A, v̄perp, di, ωci)
   ωbulk = dispersion_bulk_flow(krange, θ, v̄perp, di, ωci)
   # Window filtering for avoiding spectral leakage
   window = hanning(npoints) * hanning(nfile)&#39;

   meta = load(files[end])

   for i in eachindex(varnames)
      println(&quot;variable name: &quot;, varnames[i])
      var = extract_var(files, varnames[i], cellids, distances, components[i])

      # 2DFFT
      F̃ = window .* var |&gt; fft |&gt; fftshift

      # Visualization
      fig = figure(figsize=(12,12), constrained_layout=false)
      ax = [subplot(221), subplot(223), subplot(222), subplot(224, projection=&quot;3d&quot;)]

      dispersion = reverse!(abs.(F̃.*F̃)[:, end-nt+1:end]&#39;, dims=1)
      im1 = ax[1].pcolormesh(krange, ωrange, dispersion, norm=matplotlib.colors.LogNorm())

      ax[1].plot([krange[1], 0.0, krange[end]], [ωCFL[1], 0.0, ωCFL[end]], &quot;--&quot;,
         linewidth=1.0, color=&quot;k&quot;, label=&quot;CFL Condition&quot;)
      ax[1].plot(krange, ωfast, &quot;--&quot;,
         linewidth=1.2, color=&quot;#d62728&quot;, label=&quot;Fast Mode&quot;)
      ax[1].plot(krange, ωbulk, &quot;--&quot;,
         linewidth=1.2, color=&quot;#9467bd&quot;, label=&quot;Flow Speed&quot;)

      ax[1].set_xlim(kmin, kmax)
      ax[1].set_ylim(ωmin, ωmax)

      cb = colorbar(im1; ax=ax[1])
      cb.ax.tick_params(direction=&quot;in&quot;)
      ax[1].legend(;fontsize=&quot;x-small&quot;)
      ax[1].set_xlabel(L&quot;$k_\perp \cdot d_i$&quot;)
      ax[1].set_ylabel(L&quot;$\omega/\Omega_{ci}$&quot;)
      ax[1].set_title(L&quot;$k_\perp$ angle w.r.t. x = %$θ&quot;)

      im2 = ax[2].pcolormesh((distances .+ coords[1,1])./RE, t, var&#39;)

      ax[2].plot((xwave[1] .+ coords[1,1])./RE, twave, &quot;.--&quot;,
         color=&quot;#d62728&quot;, label=L&quot;$V_{bulk}$&quot;)
      ax[2].plot((xwave[2] .+ coords[1,1])./RE, twave, &quot;.--&quot;,
         color=&quot;#9467bd&quot;,  label=L&quot;$V_{bulk} + V_{fast}$&quot;)
      ax[2].plot((xwave[3] .+ coords[1,1])./RE, twave, &quot;.--&quot;,
         color=&quot;#ff7f0e&quot;, label=L&quot;$V_{bulk} - V_{fast}$&quot;)

      ax[2].plot((xwave2[1] .+ coords[1,1])./RE, twave2, &quot;.--&quot;,
         color=&quot;#d62728&quot;)
      ax[2].plot((xwave2[2] .+ coords[1,1])./RE, twave2, &quot;.--&quot;,
         color=&quot;#9467bd&quot;)
      ax[2].plot((xwave2[3] .+ coords[1,1])./RE, twave2, &quot;.--&quot;,
         color=&quot;#ff7f0e&quot;)

      cb = colorbar(im2; ax=ax[2])
      cb.ax.tick_params(direction=&quot;in&quot;)

      ax[2].set_xlim(coords[1,1]/RE, coords[1,end]/RE)

      ax[2].legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.13),
         fancybox=true, shadow=true, ncol=3)
      ax[2].set_xlabel(L&quot;x [$R_E$]&quot;)
      ax[2].set_ylabel(L&quot;time [s]&quot;)
      ax[2].set_title(&quot;$(varnames_print[i])_$(components[i])&quot;)

      pArgs = Vlasiator.set_args(meta, varnames[i], axisunit; normal=:none)
      x, y = Vlasiator.get_axis(pArgs)
      data = Vlasiator.prep2d(meta, varnames[i], components[i])&#39;
      cnorm, cticks = set_colorbar(Linear, -Inf, Inf, data)
      cmesh = ax[3].pcolormesh(x, y, data, norm=cnorm)

      ax[3].set_xlabel(pArgs.strx)
      ax[3].set_ylabel(pArgs.stry)
      ax[3].set_aspect(1)

      cb = colorbar(cmesh; ax=ax[3], ticks=cticks, fraction=0.046, pad=0.04)
      cb.ax.set_ylabel(pArgs.cb_title)
      cb.ax.tick_params(direction=&quot;in&quot;)

      @views ax[3].scatter(coords[1,:]./RE, coords[2,:]./RE; s=0.2, color=&quot;k&quot;)

      xCoord = (distances .+ coords[1,1])./RE
      # meshgrid
      X = [x for _ in t, x in xCoord]
      Y = [y for y in t, _ in xCoord]

      ax[4].view_init(elev=40., azim=-30.)
      ax[4].plot_surface(X, Y, var&#39;, cmap=matplotlib.cm.turbo, antialiased=false)

      ax[4].set_xlabel(L&quot;x [$R_E$]&quot;; fontsize=&quot;small&quot;)
      ax[4].set_ylabel(&quot;time [s]&quot;; fontsize=&quot;small&quot;)
      #ax[4].set_zlabel(pArgs.cb_title)
      ax[4].tick_params(labelsize=&quot;small&quot;)

      outname = &quot;dispersion_$(varnames_print[i])_$(components[i]).png&quot;
      savefig(joinpath(outdir, outname), bbox_inches=&quot;tight&quot;)
      close(fig)
   end

end

function main()
   outdir = &quot;../out/&quot;
   γ = 5 / 3

   xStart = [10.0, 0.0, 0.0].*RE
   xEnd   = [13.3, 0.0, 0.0].*RE

   varnames = [&quot;proton/vg_rho&quot;, &quot;vg_b_vol&quot;, &quot;vg_e_vol&quot;, &quot;vg_pressure&quot;]
   varnames_print = [&quot;rho&quot;, &quot;b&quot;, &quot;e&quot;, &quot;p&quot;]
   components = [0, 3, 1, 0] # 0 for scalar, 1-3 for vector components

   dir = &quot;../run_rho2_bz-5_timevarying_startfrom300s&quot;
   files = glob(&quot;bulk.*.vlsv&quot;, dir)

   vars = Variables(varnames, varnames_print, components)

   dtfile = 0.5                          # output interval, [s]
   Δt   = 0.0147176                      # discrete time step from runlog, [s]

   meta = load(files[1])

   if ispolar(meta) # polar plane
      @error &quot;not implemented!&quot;
   end

   cellids, distances, coords = getcellinline(meta, xStart, xEnd)

   meanstates = estimate_meanstates(files, cellids)

   println(&quot;number of extracted points: &quot;, length(cellids))
   println(&quot;xStart: &quot;, xStart)
   println(&quot;xEnd: &quot;, xEnd)
   tbegin = load(files[1]).time
   tend = load(files[end]).time
   println(&quot;time from $tbegin to $tend s&quot;)

   @time plot_dispersion(files, vars, cellids, distances, coords, meanstates, dtfile, Δt,
      outdir)
end

main()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/JuliaDocs/DemoCards.jl">DemoCards.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 28 January 2024 23:19">Sunday 28 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
