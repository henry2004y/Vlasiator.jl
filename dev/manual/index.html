<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · Vlasiator.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://henry2004y.github.io/Vlasiator.jl/manual/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Vlasiator.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Common-physical-constants"><span>Common physical constants</span></a></li><li><a class="tocitem" href="#Loading-VLSV-data"><span>Loading VLSV data</span></a></li><li><a class="tocitem" href="#Computing-derived-quantities"><span>Computing derived quantities</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Appending-to-VLSV"><span>Appending to VLSV</span></a></li><li><a class="tocitem" href="#Converting-to-VTK"><span>Converting to VTK</span></a></li><li><a class="tocitem" href="#Tracking-log-files"><span>Tracking log files</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../python/">Calling from Python</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../internal/">API Reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../log/">Log</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/henry2004y/Vlasiator.jl/blob/master/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>Here we demonstrate some basic usages of Vlasiator output processing. For complete description of the arguments, please refer to the <a href="../internal/">API</a> documents or type <code>?function_name</code> to display help message in the REPL.</p><h2 id="Common-physical-constants"><a class="docs-heading-anchor" href="#Common-physical-constants">Common physical constants</a><a id="Common-physical-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Common-physical-constants" title="Permalink"></a></h2><p>A bunch of physical constants are predefined in <a href="https://github.com/henry2004y/Vlasiator.jl/blob/master/src/vlsv/vlsvvariables.jl">Vlasiator.jl</a>. To use them, you need to import explicitly, e.g. <code>using Vlasiator: RE</code> or prepend the module name like <code>Vlasiator.RE</code>.</p><table><tr><th style="text-align: center">Physical constant</th><th style="text-align: center">Value</th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: center">qₑ</td><td style="text-align: center">-1.60217662e-19</td><td style="text-align: left">electron charge, [C]</td></tr><tr><td style="text-align: center">mₑ</td><td style="text-align: center">9.10938356e-31</td><td style="text-align: left">electron mass, [kg]</td></tr><tr><td style="text-align: center">qᵢ</td><td style="text-align: center">1.60217662e-19</td><td style="text-align: left">proton mass, [C]</td></tr><tr><td style="text-align: center">mᵢ</td><td style="text-align: center">1.673557546e-27</td><td style="text-align: left">proton mass, [kg]</td></tr><tr><td style="text-align: center">c</td><td style="text-align: center">299792458.</td><td style="text-align: left">speed of light, [m/s]</td></tr><tr><td style="text-align: center">μ₀</td><td style="text-align: center">4π*1e-7</td><td style="text-align: left">Vacuum permeability, [H/m]</td></tr><tr><td style="text-align: center">ϵ₀</td><td style="text-align: center">1/(c^2*μ₀)</td><td style="text-align: left">Vacuum permittivity, [F/m]</td></tr><tr><td style="text-align: center">kB</td><td style="text-align: center">1.38064852e-23</td><td style="text-align: left">Boltzmann constant, [m²kg/(s²K)]</td></tr><tr><td style="text-align: center">RE</td><td style="text-align: center">6.371e6</td><td style="text-align: left">Earth radius, [m]</td></tr></table><h2 id="Loading-VLSV-data"><a class="docs-heading-anchor" href="#Loading-VLSV-data">Loading VLSV data</a><a id="Loading-VLSV-data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-VLSV-data" title="Permalink"></a></h2><ul><li>Read meta data</li></ul><pre><code class="language-julia hljs">file = &quot;bulk.0000004.vlsv&quot;
meta = load(file)</code></pre><p>The VLSV meta data contains information of file name, variable names, ordinary cell ID list, mesh sizes, species, and velocity cell structures. It is often the first argument for methods defined in Vlasiator.jl.</p><ul><li>Read parameter</li></ul><p>For convenience we support the do-block syntax that automatically closes the file stream.</p><pre><code class="language-julia hljs">t = load(file) do meta
   readparameter(meta, &quot;time&quot;)
end</code></pre><ul><li>Read variable meta data</li></ul><pre><code class="language-julia hljs">readvariablemeta(meta, &quot;proton/vg_rho&quot;)</code></pre><p>A list of utility functions has been implemented for checking variable status. See <a href="../internal/#Vlasiator.hasname-Tuple{Any, Any, Any}">here</a> for the full list.</p><ul><li>Read variable</li></ul><pre><code class="language-julia hljs">data = meta[&quot;proton/vg_rho&quot;]
# Or equivalently
data = readvariable(meta, &quot;proton/vg_rho&quot;)</code></pre><p>The variable reading is designed for cells, which takes cell ID(s) as the 3rd argument if specified. The same interface works for both <a href="https://github.com/fmihpc/dccrg">DCCRG</a> grid (for storing cell centered quantities like plasma moments) and <a href="https://github.com/fmihpc/fsgrid">FS</a> grid (for storing field solver related quantities on a uniform high resolution mesh) variables. By default the returned DCCRG variable array is sorted by cell IDs. If in any case you want the original unsorted version as being stored in the file, use <code>readvariable(meta, var, false)</code>.</p><ul><li>Get variable at a given location</li></ul><pre><code class="language-julia hljs">loc = [2.0, 0.0, 0.0]
id = getcell(meta, loc)
readvariable(meta, &quot;proton/vg_rho&quot;, id)</code></pre><ul><li>Get variable along a line between two points</li></ul><pre><code class="language-julia hljs">using Vlasiator: RE # Earth radii
point1 = [12RE, 0, 0]
point2 = [15RE, 0, 0]
cellids, distances, coords = getcellinline(meta, point1, point2)
var_extract = readvariable(meta, &quot;VA&quot;, cellids)</code></pre><ul><li>Extract variable at a static cell ID from a sequence of files under the same grid</li></ul><pre><code class="language-julia hljs">extractsat(files, var, id)</code></pre><ul><li>Compare VLSV files</li></ul><p>One may want to check if two vlsv files are identical. This is tricky because</p><ol><li>the structure of VLSV format does not guarantee the writing order in parallel processing;</li><li>numerical error accumulates with floating point representation, especially with fastmath option.</li></ol><p>The <code>issame</code> method does not check quantities that are related to the MPI writing sequence: for some reasons, even file sizes may vary depending on the number of MPI processes!</p><pre><code class="language-julia hljs">issame(file1, file2)</code></pre><p>There is an optional third argument to <code>issame</code> for setting the relative difference tolerance, with default being 1e-4. In practice relative difference works better for &quot;large&quot; numbers, and absolute difference works better for &quot;small&quot; numbers.</p><h2 id="Computing-derived-quantities"><a class="docs-heading-anchor" href="#Computing-derived-quantities">Computing derived quantities</a><a id="Computing-derived-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-derived-quantities" title="Permalink"></a></h2><p>Vlasiator is capable of computing plasma moments and some predefined derived quantities and saving them directly into VLSV files. To avoid confusion about variable names, the conventions are</p><ul><li>raw quantities are all lowercases;</li><li>all predefined derived variable names start with a capital letter.</li></ul><p>To obtain a derived quantity, use either a key of string or symbol,</p><pre><code class="language-julia hljs">beta = meta[&quot;Beta&quot;]
VA = meta[:VA]</code></pre><p>Here is a full list of available quantities<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>:</p><table><tr><th style="text-align: right">Derived variable name</th><th style="text-align: right">Meaning</th><th style="text-align: right">Required variable<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></th></tr><tr><td style="text-align: right">Bmag</td><td style="text-align: right">magnetic field magnitude</td><td style="text-align: right">vg_b_vol</td></tr><tr><td style="text-align: right">Emag</td><td style="text-align: right">electric field magnitude</td><td style="text-align: right">vg_e_vol</td></tr><tr><td style="text-align: right">Vmag</td><td style="text-align: right">bulk speed</td><td style="text-align: right">vg_v</td></tr><tr><td style="text-align: right">VS</td><td style="text-align: right">sound speed</td><td style="text-align: right">vg_ptensor_diagonal; vg_rho</td></tr><tr><td style="text-align: right">VA</td><td style="text-align: right">Alfvén speed</td><td style="text-align: right">vg_rho; Bmag</td></tr><tr><td style="text-align: right">MA</td><td style="text-align: right">Alfvén Mach number</td><td style="text-align: right">Vmag; VA</td></tr><tr><td style="text-align: right">MS</td><td style="text-align: right">Sonic Mach number</td><td style="text-align: right">Vmag; VS</td></tr><tr><td style="text-align: right">Vpar</td><td style="text-align: right">bulk velocity <span>$\parallel\mathbf{B}$</span></td><td style="text-align: right">vg_v; vg_b_vol</td></tr><tr><td style="text-align: right">Vperp</td><td style="text-align: right">bulk velocity <span>$\perp \mathbf{B}$</span></td><td style="text-align: right">vg_v; vg_b_vol</td></tr><tr><td style="text-align: right">Vth</td><td style="text-align: right">proton thermal velocity</td><td style="text-align: right">P; vg_rho</td></tr><tr><td style="text-align: right">P</td><td style="text-align: right">scalar thermal pressure</td><td style="text-align: right">vg_ptensor_diagonal</td></tr><tr><td style="text-align: right">Ppar</td><td style="text-align: right">pressure <span>$\parallel\mathbf{B}$</span></td><td style="text-align: right">vg_ptensor_diagonal; vg_b_vol</td></tr><tr><td style="text-align: right">Pperp</td><td style="text-align: right">pressure <span>$\perp \mathbf{B}$</span></td><td style="text-align: right">vg_ptensor_offdiagonal; vg_b_vol</td></tr><tr><td style="text-align: right">T</td><td style="text-align: right">scalar temperature</td><td style="text-align: right">P; vg_rho</td></tr><tr><td style="text-align: right">Tpar</td><td style="text-align: right">temperature <span>$\parallel\mathbf{B}$</span></td><td style="text-align: right">vg_rho; vg_ptensor_diagonal; vg_b_vol</td></tr><tr><td style="text-align: right">Tperp</td><td style="text-align: right">temperature <span>$\perp \mathbf{B}$</span></td><td style="text-align: right">vg_rho; vg_ptensor_offdiagonal; vg_b_vol</td></tr><tr><td style="text-align: right">Tanisotropy</td><td style="text-align: right"><span>$T_\perp / T_\parallel$</span></td><td style="text-align: right">Tpar; Tperp</td></tr><tr><td style="text-align: right">J</td><td style="text-align: right">current density</td><td style="text-align: right">vg_b_vol</td></tr><tr><td style="text-align: right">Protated</td><td style="text-align: right">pressure tensor with <span>$\widehat{z} \parallel \mathbf{B}$</span></td><td style="text-align: right">vg_b_vol; vg_ptensor_diagonal; vg_ptensor_offdiagonal</td></tr><tr><td style="text-align: right">Panisotropy</td><td style="text-align: right"><span>$P_\perp / P_\parallel$</span></td><td style="text-align: right">ptensor; B</td></tr><tr><td style="text-align: right">Pram</td><td style="text-align: right">dynamic ram pressure</td><td style="text-align: right">vg_rho; Vmag</td></tr><tr><td style="text-align: right">Pb</td><td style="text-align: right">magnetic pressure</td><td style="text-align: right">vg_b_vol</td></tr><tr><td style="text-align: right">Poynting</td><td style="text-align: right">Poynting flux</td><td style="text-align: right">E; B</td></tr><tr><td style="text-align: right">Beta</td><td style="text-align: right">plasma beta, <span>$P / P_B$</span></td><td style="text-align: right">P; vg_b_vol</td></tr><tr><td style="text-align: right">BetaStar</td><td style="text-align: right">modified beta, <span>$(P + P_{ram}) / P_B$</span></td><td style="text-align: right">P; Pram; vg_b_vol</td></tr><tr><td style="text-align: right">IonInertial</td><td style="text-align: right">proton inertial length</td><td style="text-align: right">vg_rho</td></tr><tr><td style="text-align: right">Larmor</td><td style="text-align: right">proton Larmor radius</td><td style="text-align: right">Vth; Bmag</td></tr><tr><td style="text-align: right">Gyroperiod</td><td style="text-align: right">proton gyroperiod</td><td style="text-align: right">Bmag</td></tr><tr><td style="text-align: right">PlasmaPeriod</td><td style="text-align: right">plasma oscillation period</td><td style="text-align: right">vg_rho</td></tr><tr><td style="text-align: right">Gyrofrequency</td><td style="text-align: right">proton gyro-frequency</td><td style="text-align: right">Bmag</td></tr><tr><td style="text-align: right">Omegap</td><td style="text-align: right">plasma frequency (proton)</td><td style="text-align: right">vg_rho</td></tr><tr><td style="text-align: right">MagneticTension</td><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Magnetic_tension">magnetic tension force</a></td><td style="text-align: right">vg_b_vol</td></tr></table><p>which can also be found as keys of dictionary in <a href="https://github.com/henry2004y/Vlasiator.jl/blob/master/src/vlsv/vlsvvariables.jl">vlsvvariables.jl</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In Vlasiator, the cells inside the inner boundary (which is usually a sphere/circle) are filled with zero density values. This is then used to identify the inner boundary for all other quantities. Therefore, if you are manipulating directly on data, make sure that the nonsense values inside the inner boundary are excluded. One way to do this can be found in <a href="https://github.com/henry2004y/Vlasiator.jl/blob/master/src/vlsv/vlsvvariables.jl">vlsvvariables.jl</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This part has not been carefully tested so it might not work or just generate wrong results. Contributions from users are warmly welcomed!</p></div></div><h3 id="Velocity-space-moments"><a class="docs-heading-anchor" href="#Velocity-space-moments">Velocity space moments</a><a id="Velocity-space-moments-1"></a><a class="docs-heading-anchor-permalink" href="#Velocity-space-moments" title="Permalink"></a></h3><p>We can also calculate plasma moments from the saved VLSV velocity space distributions.</p><pre><code class="language-julia hljs"># VDF cell indexes and values, with sparsity
vcellids, vcellf = readvcells(meta, cellid; species=&quot;proton&quot;)

getdensity(meta, vcellf)

getvelocity(meta, vcellids, vcellf)
# pressure tensor components Pxx, Pyy, Pzz, Pyz, Pzx, Pxy
getpressure(meta, vcellids, vcellf)
# heat flux components qⱼⱼᵢ
getheatfluxvector(meta, vcellids, vcellf)</code></pre><p>To obtain the original ordering of velocity cells,</p><pre><code class="language-julia hljs">vcellids_original = Vlasiator.reorder(meta.meshes[&quot;proton&quot;], vcellids)</code></pre><p>Some useful quantities like non-Maxwellianity may be of interest. Currently we have implemented a monitor quantity named &quot;Maxwellianity&quot;, which is defined as <span>$-ln \big[ 1/(2n) \int |f(v) - g(v)| dv \big]$</span>, where n is the density, f(vᵢ) is the actual VDF value at velocity cell i, and g(vᵢ) is the analytical Maxwellian (or strictly speaking, normal) distribution with the same density, bulk velocity and scalar pressure as f.</p><pre><code class="language-julia hljs">getmaxwellianity(meta, vcellids, vcellf)</code></pre><p>The value ranges from [0, +∞], with 0 meaning not Maxwellian-distributed at all, and +∞ a perfect Maxwellian distribution.</p><p>Sometimes it may be useful to recover the full 3D array of VDFs:</p><pre><code class="language-julia hljs">f = Vlasiator.reconstruct(meta.meshes[&quot;proton&quot;], vcellids, vcellf)</code></pre><p>However, usually in practice there would be only about 1% nonzero values. The moments and maxwellianity calculations above all have an alternative form of using reconstructed VDFs as inputs.</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Vlasiator.jl does not include any plotting library as explicit dependency, but it offers plotting recipes/wrappers once the target plotting package is used.</p><p>Currently <code>PyPlot.jl</code> provides the most complete and fine-tuned plotting capabilities. <code>Plots.jl</code> is a collection of plotting libraries with a uniform frontend, but it lacks detailed supports and consistent APIs. <code>Makie.jl</code>, a native Julia plotting library, is also supported via <a href="https://github.com/henry2004y/VlasiatorMakie.jl">VlasiatorMakie.jl</a>. Without generating an system image from <code>PackageCompiler.jl</code>, it would take ~40s for the first plot on Julia 1.8. However, Makie has made nice progress in layouts, widgets, docs, and all the tiny things, which makes it a strong candidate for the de facto plotting library in the future.</p><p>More examples of customized plots can be found in the <a href="https://github.com/henry2004y/Vlasiator.jl/tree/master/src/examples">repo</a>.</p><h3 id="PyPlot-Backend"><a class="docs-heading-anchor" href="#PyPlot-Backend">PyPlot Backend</a><a id="PyPlot-Backend-1"></a><a class="docs-heading-anchor-permalink" href="#PyPlot-Backend" title="Permalink"></a></h3><p>To trigger Matplotlib plotting, <code>using PyPlot</code>. All the functions with identical names as in Matplotlib accept all possible keyword arguments supported by their Matplotlib counterparts, e.g. font width, font size, colormap, etc. Users are encouraged to read the <a href="https://matplotlib.org/">Matplotlib</a> documentation for details.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The method call to certain axes is not dispatched, e.g. <code>ax.plot</code>; as an alternative, one needs to pass <code>ax</code> as the third argument to the functions, e.g. <code>plot(meta, &quot;rho&quot;, ax)</code>. See <a href="https://aaltoscicomp.github.io/python-for-scicomp/data-visualization/#matplotlib-has-two-different-interfaces">Matplotlib&#39;s two interfaces</a> for the history of the interfaces.</p></div></div><ul><li>Scalar colored contour from 2D simulation</li></ul><pre><code class="language-julia hljs">pcolormesh(meta, &quot;rho&quot;)</code></pre><ul><li>Vector z component colored contour from 2D simulation in a manually set range</li></ul><pre><code class="language-julia hljs">pcolormesh(meta, &quot;rho&quot;, comp=:z, colorscale=Log, axisunit=EARTH, vmin=1e6, vmax=2e6)</code></pre><ul><li>Vz colored contour from 2D simulation with prescribed colormap</li></ul><pre><code class="language-julia hljs">pcolormesh(meta, &quot;proton/vg_v&quot;, comp=:z, colorscale=Linear, cmap=matplotlib.cm.RdBu_r)</code></pre><ul><li>Derived quantity colored contour from 2D simulation (as long as the input variable is in the predefined dictionary)</li></ul><pre><code class="language-julia hljs">pcolormesh(meta, &quot;b&quot;, comp=:z, colorscale=Linear, axisunit=SI)</code></pre><ul><li>Streamline from 2D simulation</li></ul><pre><code class="language-julia hljs">streamplot(meta, &quot;rho_v&quot;, comp=&quot;xy&quot;)</code></pre><ul><li>Quiver from 2D simulation</li></ul><pre><code class="language-julia hljs">quiver(meta, &quot;rho_v&quot;, comp=&quot;xy&quot;)</code></pre><p>The <code>comp</code> option is used to specify the two vector components.</p><p>You can choose to use a linear/log/symlog color scale by setting keyword <code>colorscale</code> to <code>Linear</code>, <code>Log</code>, or <code>SymLog</code>, plot vector components by setting keyword <code>op</code> to <code>:x</code>, <code>:y</code>, <code>:z</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>0</code> or <code>:mag</code>, and set <code>axisunit</code> to <code>EARTH</code> or <code>SI</code> etc.</p><ul><li>Mesh denoted by cell centers</li></ul><pre><code class="language-julia hljs">plotmesh(meta; projection=&quot;z&quot;, color=&quot;w&quot;)</code></pre><ul><li>Cut slice colored contour from 3D simulation</li></ul><pre><code class="language-julia hljs">pcolormesh(meta, &quot;proton/vg_rho&quot;, normal=:y, origin=0.0)</code></pre><ul><li>Velocity distribution slice plot near a given spatial location <code>coordinates = [0.0, 0.0, 0.0]</code></li></ul><pre><code class="language-julia hljs">vdfslice(meta, coordinates)</code></pre><ul><li>Extracted quantity line plot</li></ul><pre><code class="language-julia hljs">rho_extract = vec(rho_extract)
loc = range(x1, x2, length=length(rho_extract))
plot(loc, rho_extract)</code></pre><ul><li>Quick interactive REPL-based function for data inspection</li></ul><pre><code class="language-julia hljs">pui(meta)</code></pre><p>Or pass filename directly like <code>pui(file)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an experimental feature. We plan to have GUI-based plotting support in the future.</p></div></div><p>For a full list available optional arguments, please refer to the <a href="../internal/#Public-APIs">doc for each method</a></p><h3 id="Plots-Backend"><a class="docs-heading-anchor" href="#Plots-Backend">Plots Backend</a><a id="Plots-Backend-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-Backend" title="Permalink"></a></h3><p>To trigger Plots.jl plotting, <code>using Plots</code>. This backend supports all available attributes provided by <a href="http://docs.juliaplots.org/latest/">Plots.jl</a>. By default it uses <a href="https://gr-framework.org/">GR</a>, but several other plotting libraries are also supported.</p><ul><li>Scaler colored contour from 2D simulation</li></ul><pre><code class="language-julia hljs">heatmap(meta, var, aspect_ratio=:equal, c=:turbo)</code></pre><ul><li>Scaler colored contour with lines from 2D simulation</li></ul><pre><code class="language-julia hljs">contourf(meta, var)</code></pre><ul><li>VDF projected slice in a normal direction</li></ul><pre><code class="language-julia hljs">vdfslice(meta, location)</code></pre><p>The keyword arguments are the same as in the PyPlot shown in the <a href="../internal/#Vlasiator.vdfslice">API</a>.</p><h3 id="Makie-Backend"><a class="docs-heading-anchor" href="#Makie-Backend">Makie Backend</a><a id="Makie-Backend-1"></a><a class="docs-heading-anchor-permalink" href="#Makie-Backend" title="Permalink"></a></h3><p>A standalone package <a href="https://github.com/henry2004y/VlasiatorMakie.jl">VlasiatorMakie.jl</a> is designed for plotting with Makie. To trigger Makie plotting with OpenGL, <code>using VlasiatorMakie, GLMakie</code>. You can either use intrinsic Makie plotting methods like</p><pre><code class="language-julia hljs">lines(meta, var)   # 1D
heatmap(meta, var) # 2D</code></pre><p>or use full recipes provided by VlasiatorMakie</p><pre><code class="language-julia hljs">vlheatmap(meta, var)</code></pre><p>For quick inspection of data, we have</p><ul><li>2D slices of 3D AMR data</li></ul><pre><code class="language-julia hljs">vlslice(meta, var; normal=:x)</code></pre><ul><li>Orthognal slices of 3D AMR data</li></ul><pre><code class="language-julia hljs">vlslices(meta, var)</code></pre><ul><li>2D slice of VDFs at a spatial cell</li></ul><pre><code class="language-julia hljs">vdfslice(meta, location)</code></pre><ul><li>Orthognal slices of VDFs at a spatial cell</li></ul><pre><code class="language-julia hljs">vdfslices(meta, location)</code></pre><ul><li>3D scatter of VDFs at a spatial cell</li></ul><pre><code class="language-julia hljs">vdfvolume(meta, location)</code></pre><p>The interactive plots are available through the OpenGL backend of Makie <code>GLMakie</code>. For noninteractive high fidelity plots, we can also use the Cairo backend of Makie <code>CairoMakie</code>. Other options can be found at <a href="https://makie.juliaplots.org/stable/#makie_ecosystem">Makie Ecosystem</a>.</p><h2 id="Appending-to-VLSV"><a class="docs-heading-anchor" href="#Appending-to-VLSV">Appending to VLSV</a><a id="Appending-to-VLSV-1"></a><a class="docs-heading-anchor-permalink" href="#Appending-to-VLSV" title="Permalink"></a></h2><p>We are able to compute derived quantities from an original VLSV file and generate a new VLSV output with new quantities included.</p><pre><code class="language-julia hljs">vmag = readvariable(meta, &quot;Vmag&quot;, meta.cellid)
pa = readvariable(meta, &quot;Panisotropy&quot;, meta.cellid)
vars = Vector{Tuple{VecOrMat, String, VarInfo}}(undef, 0)
# require LaTeXStrings.jl
push!(vars, (vmag, &quot;vmag&quot;, VarInfo(&quot;m/s&quot;, L&quot;$\mathrm{m}/mathrm{s}$&quot;, L&quot;$V$&quot;, &quot;&quot;)))
push!(vars, (pa, &quot;panisotropy&quot;, VarInfo(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)))

write_vlsv(&quot;bulk.vlsv&quot;, &quot;bulk_new.vlsv&quot;, vars)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Writing new FsGrid variables is not supported. All quantities from the original file is maintained.</p></div></div><h2 id="Converting-to-VTK"><a class="docs-heading-anchor" href="#Converting-to-VTK">Converting to VTK</a><a id="Converting-to-VTK-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-to-VTK" title="Permalink"></a></h2><p>We can convert VLSV files into VTK format. Since DCCRG is Cartesian based with uniform spacing, each level of mesh refinement corresponds to a VTK image file, and the cell refinement relationships are stored in <code>vtkGhostType</code> as well as the <code>vthb</code> file.</p><p>To convert a VLSV file into VTK,</p><pre><code class="language-julia hljs">write_vtk(file)</code></pre><p>This function accepts either string of file names or <code>MetaVLSV</code>.</p><p>To see the full list of options, please refer to the documentation in <a href="../internal/">API Reference</a>. Example usage can be found <a href="https://github.com/henry2004y/Vlasiator.jl/blob/master/examples/demo_convert2vti.jl">here</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As of ParaView 5.9.1, there are <a href="https://discourse.paraview.org/t/vthb-file-structure/7224">display issues</a> with <code>VTKOverlappingAMR</code>. However, we can read the generated image files directly. There is also an keyword argument for <code>write_vtk</code> called <code>maxamronly</code>: when it is set to <code>true</code>, then only the image file at the highest refinement level is generated. This part is experimental and subject to change in the future.</p></div></div><h2 id="Tracking-log-files"><a class="docs-heading-anchor" href="#Tracking-log-files">Tracking log files</a><a id="Tracking-log-files-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking-log-files" title="Permalink"></a></h2><p>The runtime performance per iteration can be monitored through log files:</p><pre><code class="language-julia hljs">file = &quot;logfile.txt&quot;
timestamps, speed = readlog(file)</code></pre><p>See a live example at <a href="https://github.com/henry2004y/Vlasiator.jl/tree/master/examples/demo_log.jl">demo_log.jl</a>.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>More <a href="https://github.com/henry2004y/Vlasiator.jl/tree/master/examples">examples</a> are provided about</p><ul><li>Plotting with PyPlot</li><li>Plotting with Plots</li><li>Extracing variable along a line</li><li>Field line tracing</li><li>Simulation log file tracking</li><li>Converting VLSV to VTK format</li><li>Parallel post-processing</li><li>Finding X-points and O-points in 2D reconnection</li></ul><p>Feel free to check those out and try on your data!</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For species specific variables, you need to add the species name at the front, separated by a slash. For example, the proton bulk velocity is a string <code>proton/vg_v</code>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>If a required variable exists in the VLSV file, we try to use it directly instead of calculating from other variables. The interpolated FS grid variables onto DCCRG grid are preferred over original FS grid variables.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../python/">Calling from Python »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 14 October 2022 09:34">Friday 14 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
