var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Try to explain your contribution with simple language.\nReferences are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/#Reporting-issues","page":"Contributing","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and Vlasiator.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/#Feature-requests","page":"Contributing","title":"Feature requests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in Vlasiator.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/#Code-contribution","page":"Contributing","title":"Code contribution","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you have code that you would like to contribute to Vlasiator.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"] activate @dev","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This will create a fresh environment called @dev where you can play with the project components without compromising your normal user environment.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"] dev Vlasiator","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This will clone all the project components in your ~/.julia folder so that you can modify it and submit a pull request on GitHub later. Don't hesitate to ask questions. We are looking forward to your contributions.","category":"page"},{"location":"manual/#Manual","page":"User Guide","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Here we demonstrate some basic usages of Vlasiator output processing. For more complete description of the arguments, please refer to the API documents or type ?foo to display help message in the REPL.","category":"page"},{"location":"manual/#Common-physical-constants","page":"User Guide","title":"Common physical constants","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"A bunch of physical constants are predefined in Vlasiator.jl. To use them, you need to import explicitly, e.g. using Vlasiator: Re or prepend the module name like Vlasiator.Re.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Physical constant Value Meaning\nqₑ -1.60217662e-19 electron charge, [C]\nmₑ 9.10938356e-31 electron mass, [kg]\nqᵢ 1.60217662e-19 proton mass, [C]\nmᵢ 1.673557546e-27 proton mass, [kg]\nc 299792458. speed of light, [m/s]\nμ₀ 4π*1e-7 Vacuum permeability, [H/m]\nϵ₀ 1/(c^2*μ₀) Vacuum permittivity, [F/m]\nkB 1.38064852e-23 Boltzmann constant, [m²kg/(s²K)]\nRe 6.371e6 Earth radius, [m]","category":"page"},{"location":"manual/#Loading-VLSV-data","page":"User Guide","title":"Loading VLSV data","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Read meta data","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"file = \"bulk.0000004.vlsv\"\nmeta = load(file)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"This VLSV meta data contains information of file names, variable names, cell ID list, mesh sizes and species, which can then be passed into all kinds of methods that process the data.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Read parameter","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"For convenience we support the do-block syntax that automatically closes the file stream.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"t = load(file) do meta\n   readparameter(meta, \"time\")\nend","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Read variable meta data","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"readvariablemeta(meta, \"proton/vg_rho\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"A list of utility functions has been implemented for checking variable status. See here for the full list.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Read variable","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"data = meta[\"proton/vg_rho\"]\n# Or equivalently\ndata = readvariable(meta, \"proton/vg_rho\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The variable reading is designed for cells, which takes cell ID(s) as inputs, although the same interface works for both DCCRG grid and FS grid variables. By default the returned DCCRG grid variable array is sorted by cell IDs. If in any case you want the original unsorted version as being stored in the file, use readvariable(meta, var, false).","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Get variable at a given location","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"loc = [2.0, 0.0, 0.0]\nid = getcell(meta, loc)\nreadvariable(meta, \"proton/vg_rho\", id)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Get variable along a line between two points","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"using Vlasiator: Re # Earth radii\npoint1 = [12Re, 0, 0]\npoint2 = [15Re, 0, 0]\ncellids, distances, coords = getcellinline(meta, point1, point2)\nvar_extract = readvariable(meta, \"VA\", cellids)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Compare VLSV files","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"One may want to check if two vlsv files are identical. This is tricky because","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"the structure of VLSV format does not guarantee parallel writing order;\nnumerical error accumulates with floating point representation.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The key is that we should not check quantities that are related to MPI writing sequence: for some reasons, even file sizes may vary depending on the number of MPI processes!","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"issame(file1, file2)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"There is an optional third argument to issame for setting the relative difference tolerance, with default being 1e-4. In practice relative difference works better for \"large\" numbers, and absolute difference works better for \"small\" numbers.","category":"page"},{"location":"manual/#Computing-derived-quantities","page":"User Guide","title":"Computing derived quantities","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Vlasiator is capable of computing moments and some derived quantities and save them directly into VLSV files. More derived quantities computed from the saved quantities are also available in postprocessing, such as plasma β, velocity parallel/perpendicular to the magnetic field, pressure tensor with the third axis aligned with the magnetic field direction and so on. To avoid confusion about variable names, the convention here is that","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"if it is directly stored in the VLSV file, read the raw data;\notherwise check the availability in the derived variable list. All predefined names start with a capital letter.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To obtain a derived quantity, use either keys of string or symbol,","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"beta = meta[\"Beta\"]\nVA = meta[:VA]","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Here is a full list of available quantities[1]:","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Derived variable name Meaning Required variable[2]\nBmag magnetic field magnitude vg_b_vol\nEmag electric field magnitude vg_e_vol\nVmag bulk speed vg_v\nVS sound speed vg_ptensor_diagonal; vg_rho\nVA Alfvén speed vg_rho; Bmag\nMA Alfvén Mach number Vmag; VA\nMS Sonic Mach number Vmag; VS\nVpar bulk velocity parallelmathbfB vg_v; vg_b_vol\nVperp bulk velocity perp mathbfB vg_v; vg_b_vol\nVth proton thermal velocity P; vg_rho\nP scalar thermal pressure vg_ptensor_diagonal\nPpar pressure parallelmathbfB vg_ptensor_diagonal; vg_b_vol\nPperp pressure perp mathbfB vg_ptensor_offdiagonal; vg_b_vol\nT scalar temperature P; vg_rho\nTpar temperature parallelmathbfB vg_rho; vg_ptensor_diagonal; vg_b_vol\nTperp temperature perp mathbfB vg_rho; vg_ptensor_offdiagonal; vg_b_vol\nTanisotropy T_perp  T_parallel Tpar; Tperp\nJ current density vg_b_vol\nProtated pressure tensor with widehatz parallel mathbfB vg_b_vol; vg_ptensor_diagonal; vg_ptensor_offdiagonal\nPanisotropy P_perp  P_parallel ptensor; B\nPdynamic dynamic pressure vg_rho; Vmag\nPb magnetic pressure vg_b_vol\nPoynting Poynting flux E; B\nBeta plasma beta, P  P_B P; vg_b_vol\nIonInertial proton inertial length vg_rho\nLarmor proton Larmor radius Vth; Bmag\nGyroperiod proton gyroperiod Bmag\nPlasmaperiod plasma oscillation period vg_rho\nGyrofrequency proton gyro-frequency Bmag\nOmegap plasma frequency (proton) vg_rho","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"which can also be found as keys of dictionary in vlsvvariables.jl.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"[1]: For species specific variables, you need to add the species name at the front, separated by a slash. For example, the proton bulk velocity is a string proton/vg_v.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"[2]: If a required variable exists in the VLSV file, we try to use it directly instead of calculating from other variables. The interpolated FS grid variables onto DCCRG grid are preferred over original FS grid variables.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"note: Note\nIn Vlasiator, the cells inside the inner boundary (which is usually a sphere/circle) are filled with zero density values. This is then used to identify the inner boundary for all other quantities. Therefore, if you are manipulating directly on data, make sure that the nonsense values inside the inner boundary are excluded. One way to do this can be found in vlsvvariables.jl.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"warning: Warning\nThis part has not been carefully tested so it might not work or just generate wrong results. Contributions from users are warmly welcomed!","category":"page"},{"location":"manual/#Velocity-space-moments","page":"User Guide","title":"Velocity space moments","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"We can also calculate the plasma moments from the saved VLSV velocity space distributions.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"# VDF cell indexes and values, with sparsity\nvcellids, vcellf = readvcells(meta, cellid; species=\"proton\")\n# Recover the full VDF space\nf = Vlasiator.flatten(meta.meshes[\"proton\"], vcellids, vcellf)\n\ngetdensity(meta, f)\ngetdensity(meta, vcellids, vcellf)\n\ngetvelocity(meta, f)\ngetvelocity(meta, vcellids, vcellf)\n\ngetpressure(meta, f) # only support full VDF for now","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Some useful quantities like non-Maxwellianity may be of interest. Currently we have implemented a monitor quantity named \"Maxwellianity\", which is defined as -ln big( 1(2n) int f - g dv big), where n is the density, f(vᵢ) is the actual VDF value at velocity cell i, and g(vᵢ) is the analytical Maxwellian (or strictly speaking, normal) distribution with the same density and scalar pressure as f.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"getmaxwellianity(meta, f)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The value ranges from [0, +∞], with 0 meaning not Maxwellian-distributed at all, and +∞ a perfect Maxwellian distribution.","category":"page"},{"location":"manual/#Plotting","page":"User Guide","title":"Plotting","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Vlasiator.jl does not include any plotting library as explicit dependency, but it offers plotting functionalities once the target plotting package is used.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Currently PyPlot.jl provides the most complete and fine-tuned plotting capabilities. Plots.jl is catching up, but it is still slower and lack of features. Makie.jl is supported experimentally. Without generating an image from PackageCompiler.jl, it would take ~60s for the first plot. However, Makie has made nice progress in layouts, widgets, docs, demos and all the tiny things, which makes it a strong candidate for the suggested backend.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"More examples of customized plots can be found in the repo.","category":"page"},{"location":"manual/#PyPlot-Backend","page":"User Guide","title":"PyPlot Backend","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To trigger the Matplotlib plotting, using PyPlot. All the functions with identical names as in Matplotlib accept all possible keyword arguments supported by their Matplotlib counterparts, e.g. font width, font size, colormap, etc.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"warning: Warning\nThe method call to certain axes is not dispatched, e.g. ax.plot; as an alternative, one needs to pass ax as the third argument to the functions, e.g. plot(meta, \"rho\", ax). See Matplotlib's two interfaces for details.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Scalar colored contour from 2D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"pcolormesh(meta, \"rho\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Vector z component colored contour from 2D simulation in a manually set range","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"pcolormesh(meta, \"rho\", op=:z, colorscale=Log, axisunit=RE, vmin=1e6, vmax=2e6)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Vz colored contour from 2D simulation with prescribed colormap","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"pcolormesh(meta, \"proton/vg_v\", op=:z, colorscale=Linear, cmap=matplotlib.cm.RdBu_r)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Derived quantity colored contour from 2D simulation (as long as the input variable is in the predefined dictionary)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"pcolormesh(meta, \"b\", op=:z, colorscale=Linear, axisunit=SI)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Streamline from 2D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"streamplot(meta, \"rho_v\", comp=\"xy\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Quiver from 2D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"quiver(meta, \"rho_v\", comp=\"xy\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The comp option is used to specify the two vector components.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"note: Note\nCurrently there is limited support for derived variables. This will be expanded and changed later for ease of use!","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"You can choose to use linear/log color scale via colorscale=Linear or colorscale=Log, plot vector components via e.g. op=:x or magnitude by default, and set unit via axisunit=RE etc..","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Mesh denoted by cell centers","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"plotmesh(meta; projection=\"z\", color=\"w\")","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Cut slice colored contour from 3D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"pcolormesh(meta, \"proton/vg_rho\", normal=:y, origin=0.0)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Velocity distribution function near a given spatial location coordinates = [0.0, 0.0, 0.0]","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vdfslice(meta, coordinates)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Extracted quantity line plot","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"rho_extract = vec(rho_extract)\nloc = range(x1, x2, length=length(rho_extract))\nplot(loc, rho_extract)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"For a full list available optional arguments, please refer to the doc for each method","category":"page"},{"location":"manual/#Plots-Backend","page":"User Guide","title":"Plots Backend","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To trigger the Plots package plotting, using Plots. This backend supports all available attributes provided by Plots.jl. By default it uses GR, but a wide range of other options are also presented.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Scaler colored contour from 2D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"heatmap(meta, var, aspect_ratio=:equal, c=:turbo)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Scaler colored contour with lines from 2D simulation","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"contourf(meta, var)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"VDF projected slice in a normal direction","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vdfslice(meta, location)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The keyword arguments are the same as in the PyPlot shown in the API.","category":"page"},{"location":"manual/#Makie-Backend","page":"User Guide","title":"Makie Backend","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"A standalone package VlasiatorMakie.jl is designed for plotting with Makie. You can either use intrinsic Makie plotting methods like","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"lines(meta, var)   # 1D\nheatmap(meta, var) # 2D","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"or use full recipes created by us","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vlheatmap(meta, var)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"For quickly inspecting the data, we have","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"2D slices of 3D AMR data","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vlslice(meta, var; normal=:x)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Orthognal slices of 3D AMR data","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vlslices(meta, var)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"2D slice of VDFs at a spatial cell","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vdfslice(meta, location)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Orthognal slices of VDFs at a spatial cell","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vdfslices(meta, location)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"3D scatter of VDFs at a spatial cell","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vdfvolume(meta, location)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The interactive plots are available through the OpenGL backend of Makie GLMakie. For noninteractive high fidelity plots, we can also use the Cairo backend of Makie CairoMakie.","category":"page"},{"location":"manual/#Converting-to-VTK","page":"User Guide","title":"Converting to VTK","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"We can convert VLSV files into VTK files! Since DCCRG is Cartesian based with uniform spacing, each level of refinement corresponds to a VTK image file, and the cell refinement relationships are defined by vtkGhostType as well as the vthb file.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To convert a VLSV file into VTK,","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"write_vtk(file)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"This function accepts both file names and file meta.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To see the full list of options, please refer to the documentation in API Reference. Demo usage can be found here.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"warning: Warning\nAs of ParaView 5.9.1, there are display issues with VTKOverlappingAMR. However, we can read the generated image files directly. There is also an keyword argument for write_vtk called maxamronly: when it is set to true, then only the image file at the highest refinement level is generated. This part is experimental and subject to change in the future.","category":"page"},{"location":"manual/#Appending-to-VLSV","page":"User Guide","title":"Appending to VLSV","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"We are able to compute derived quantities from an original VLSV file and generate a new VLSV output with new quantities included.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"vmag = readvariable(meta, \"Vmag\", meta.cellid)\npa = readvariable(meta, \"Panisotropy\", meta.cellid)\nvars = Vector{Tuple{VecOrMat, String, VarInfo}}(undef, 0)\n# require LaTeXStrings.jl\npush!(vars, (vmag, \"vmag\", VarInfo(\"m/s\", L\"$\\mathrm{m}/mathrm{s}$\", L\"$V$\", \"\")))\npush!(vars, (pa, \"panisotropy\", VarInfo(\"\", \"\", \"\", \"\")))\n\nwrite_vlsv(\"bulk.vlsv\", \"bulk_new.vlsv\", vars)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"note: Note\nCurrently we only support writing new DCCRG variables. All quantities from the original file is maintained.","category":"page"},{"location":"manual/#Tracking-log-files","page":"User Guide","title":"Tracking log files","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"The runtime performance per iteration can be monitored through log files:","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"file = \"logfile.txt\"\ntimestamps, speed = readlog(file)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"See a live example at demo_log.jl.","category":"page"},{"location":"manual/#Calling-from-Python","page":"User Guide","title":"Calling from Python","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"It is possible to call this package directly from Python with the aid of PyJulia. Following the installation steps described in the manual[3], and then inside Python REPL:","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"# Handling initialization issue for Conda\nfrom julia.api import Julia\njl = Julia(compiled_modules=False)\n\nfrom julia import Vlasiator\nfile = \"bulk1.0001000.vlsv\"\nmeta = Vlasiator.load(file)\nvar = \"proton/vg_rho\"\ndata = Vlasiator.readvariable(meta, var)","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"To run a Julia script in Python,","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"# Handling initialization issue for Conda\nfrom julia.api import Julia\njl = Julia(compiled_modules=False)\njl.eval('include(\"examples/demo_2dplot_pyplot.jl\")')\nimport matplotlib.pyplot as plt\nplt.show()","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"note: Note\nThis approach is for you to have a taste of the package with a Python frontend. The workaround shown above for handling the static python libraries makes it slow for regular use. An alternative solution would be creating system images, but as of Julia 1.6 the user experience is not smooth. For better integrated experience with its full power, it is recommended to use the package inside Julia.","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"[3]: For Debian-based Linux distributions, it gets a little bit tricky. Please refer to Troubleshooting for details.","category":"page"},{"location":"manual/#Examples","page":"User Guide","title":"Examples","text":"","category":"section"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"There is a list of complete examples about:","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Plotting with PyPlot\nPlotting with Plots\nVariable extraction along a line\nField line tracing\nSimulation log file tracking\nConverting VLSV to VTK format\nParallel post-processing","category":"page"},{"location":"manual/","page":"User Guide","title":"User Guide","text":"Feel free to check those out and try on your data!","category":"page"},{"location":"internal/#Internal","page":"API Reference","title":"Internal","text":"","category":"section"},{"location":"internal/#Public-APIs","page":"API Reference","title":"Public APIs","text":"","category":"section"},{"location":"internal/","page":"API Reference","title":"API Reference","text":"Modules = [Vlasiator]\nPrivate = false\nOrder = [:constant, :type, :function]","category":"page"},{"location":"internal/#Vlasiator.MetaVLSV","page":"API Reference","title":"Vlasiator.MetaVLSV","text":"VLSV meta data.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Vlasiator.VarInfo","page":"API Reference","title":"Vlasiator.VarInfo","text":"Variable MetaVLSV from the vlsv footer.\n\n\n\n\n\n","category":"type"},{"location":"internal/#PyPlot.pcolormesh","page":"API Reference","title":"PyPlot.pcolormesh","text":"pcolormesh(meta::MetaVLSV, var::AbstractString, ax=nothing;\n   op=:mag, axisunit=RE, colorscale=Linear, vmin=-Inf, vmax=Inf, addcolorbar=true,\n   kwargs...)\n\nPlot a variable using pseudocolor from 2D VLSV data. If ax is provided, then it will plot on that axes. If 3D or AMR grid detected, it will pass arguments to pcolormeshslice.\n\nOptional arguments\n\nop::Symbol: the component of a vector, chosen from :mag, :x, :y, :z, :1, :2, :3.\naxisunit::AxisUnit: the unit of axis ∈ RE, SI.\ncolorscale::ColorScale: Linear, Log, or SymLog.\nvmin::Float: minimum data range. Set to maximum of data if not specified.\nvmax::Float: maximum data range. Set to minimum of data if not specified.\naddcolorbar::Bool: whether to add a colorbar to the colormesh.\n\npcolormesh(meta, var)\n\npcolormesh(meta, var, axisunit=SI)\n\npcolormesh(data, func, colorscale=Log)\n\n\n\n\n\n","category":"function"},{"location":"internal/#PyPlot.plot","page":"API Reference","title":"PyPlot.plot","text":"plot(meta, var, ax=nothing; kwargs)\n\nPlot var from meta of 1D VLSV data. If ax===nothing, plot on the current active axes.\n\n\n\n\n\n","category":"function"},{"location":"internal/#PyPlot.quiver","page":"API Reference","title":"PyPlot.quiver","text":"quiver(meta, var, ax=nothing; comp=\"xy\", axisunit=RE, stride=10, kwargs...)\n\nWrapper over Matplotlib's quiver function. If ax===nothing, plot on the current active axes. The comp option can take a subset of \"xyz\" in any order. axisunit can be chosen from RE, SI. The keyword arguments can be any valid Matplotlib arguments into quiver.\n\nOptional arguments\n\ncomp: a subset of \"xyz\" in any order.\naxisunit: chosen from RE and SI.\nstride::Integer: arrow strides in number of cells.\n\n\n\n\n\n","category":"function"},{"location":"internal/#PyPlot.streamplot","page":"API Reference","title":"PyPlot.streamplot","text":"streamplot(meta, var, ax=nothing; comp=\"xy\", axisunit=RE, kwargs...)\n\nWrapper over Matplotlib's streamplot function. The comp option can take a subset of \"xyz\" in any order. axisunit can be chosen from RE, SI. The keyword arguments can be any valid Matplotlib arguments into streamplot.\n\nOptional arguments\n\ncomp: a subset of \"xyz\" in any order.\naxisunit: chosen from RE and SI.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.getcell-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getcell","text":"getcell(meta, location) -> UInt\n\nReturn cell ID containing the given spatial location, excluding domain boundaries. Only accept 3D location.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getcellcoordinates-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.getcellcoordinates","text":"getcellcoordinates(meta, cid) -> SVector{Float64}\n\nReturn a given cell's coordinates.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getcellinline-Tuple{MetaVLSV, Any, Any}","page":"API Reference","title":"Vlasiator.getcellinline","text":"getcellinline(meta, point1, point2) -> cellids, distances, coords\n\nReturns cell IDs, distances and coordinates for every cell in a line between two given points point1 and point2. May be improved later with preallocation!\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getcellwithvdf-Tuple{MetaVLSV}","page":"API Reference","title":"Vlasiator.getcellwithvdf","text":"getcellwithvdf(meta) -> cellids\n\nGet all the cell IDs with VDF saved.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getchildren-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.getchildren","text":"getchildren(meta, cid) -> Vector{Int}\n\nReturn direct children of cid.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getdensity-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getdensity","text":"getdensity(meta, VDF; species=\"proton\")\ngetdensity(meta, vcellids, vcellf; species=\"proton\")\n\nGet density from VDF, n = ∫ f(r,v) dV.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getlevel-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.getlevel","text":"getlevel(meta, cid) -> Int\n\nReturn the AMR level of a given cell ID. Note that this function does not check if the VLSV file of meta actually contains cid: it may be shadowed by refined children.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getmaxwellianity-Tuple{Any, Any}","page":"API Reference","title":"Vlasiator.getmaxwellianity","text":"getmaxwellianity(meta, VDF; species=\"proton\")\n\nObtain the Maxwellian similarity factor -log(1/(2n) * ∫ |f - g| dv), where f is the VDF from Vlasiator and g is the analytical Maxwellian distribution that generates the same density as f. The value ranges from [0, +∞], with 0 meaning not Maxwellian-distributed at all, and +∞ a perfect Maxwellian distribution.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getnearestcellwithvdf-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getnearestcellwithvdf","text":"getnearestcellwithvdf(meta, id) -> UInt\n\nFind the nearest spatial cell with VDF saved of a given cell id in the file meta.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getparent-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.getparent","text":"getparent(meta, cid) -> Int\n\nReturn the parent cell ID of given child cid.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getpressure-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getpressure","text":"getpressure(VDF)\n\nGet pressure tensor from VDF, pᵢⱼ = m/3 * ∫ (v - u)ᵢ(v - u)ⱼ * f(r,v) dV.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getsiblings-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.getsiblings","text":"getsiblings(meta, cid) -> Vector{Int}\n\nReturn sibling cells of a given cid, including itself.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getslicecell-Tuple{MetaVLSV, Any, Any, Any, Any}","page":"API Reference","title":"Vlasiator.getslicecell","text":"getslicecell(meta, sliceoffset, idim, minCoord, maxCoord) -> idlist, indexlist\n\nFind the cell ids idlist which are needed to plot a 2d cut through of a 3d mesh, in a direction idim at sliceoffset, and the indexlist, which is a mapping from original order to the cut plane and can be used to select data onto the plane.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getvcellcoordinates-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getvcellcoordinates","text":"getvcellcoordinates(meta, vcellids, species=\"proton\")\n\nReturn velocity cells' coordinates of species and vcellids.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getvelocity-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getvelocity","text":"getvelocity(meta, VDF; species=\"proton\")\ngetvelocity(meta, vcellids, vcellf; species=\"proton\")\n\nGet bulk velocity from VDF, u = ∫ v * f(r,v) dV / n.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.hasname-Tuple{Any, Any, Any}","page":"API Reference","title":"Vlasiator.hasname","text":"Check if the XML element contains a tag with name.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.hasparameter-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.hasparameter","text":"hasparameter(meta, param) -> Bool\n\nCheck if the vlsv file contains a certain parameter.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.hasvariable-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.hasvariable","text":"hasvariable(meta, var) -> Bool\n\nCheck if the VLSV file contains a variable.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.isparent-Tuple{MetaVLSV, Integer}","page":"API Reference","title":"Vlasiator.isparent","text":"isparent(meta, cid) -> Bool\n\nCheck if cid is a parent cell.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.issame","page":"API Reference","title":"Vlasiator.issame","text":"issame(file1, file2, tol=1e-4; verbose=false) -> Bool\n\nCheck if two VLSV files are approximately identical.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.load-Tuple{AbstractString}","page":"API Reference","title":"Vlasiator.load","text":"load(file) -> MetaVLSV\n\nReturn MetaVLSV from a vlsv file.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.pcolormeshslice","page":"API Reference","title":"Vlasiator.pcolormeshslice","text":"pcolormeshslice(meta, var, ax=nothing; kwargs...)\n\nPlot pseudocolor var on a 2D slice of 3D vlsv data. If ax is provided, then it will plot on that axes. It would be easier to call pcolormesh, since it auto-detects dimension.\n\nOptional arguments\n\nop::Symbol: the component of a vector, chosen from :mag, :x, :y, :z, :1, :2, :3.\norigin::Float: center of slice plane in the normal direction.\nnormal::Symbol: the normal direction of cut plane, chosen from :x, :y, :z.\naxisunit::AxisUnit: the unit of axis ∈ RE, SI.\ncolorscale::ColorScale: color scale for data ∈ (Linear, Log, SymLog)\nvmin::Real: minimum data range. Set to maximum of data if not specified.\nvmax::Real: maximum data range. Set to minimum of data if not specified.\naddcolorbar::Bool: whether to add a colorbar to the colormesh.\n\npcolormeshslice(meta, var)\n\npcolormeshslice(meta, var, op=:z, origin=1.0, normal=:x)\n\npcolormeshslice(data, func, colorscale=Log)\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.plotmesh","page":"API Reference","title":"Vlasiator.plotmesh","text":"plotmesh(meta; projection=\"3d\", origin=0.0, marker=\"+\", kwargs...)\n\nPlot mesh cell centers from axis view projection. projection should be either \"3d\", \"x\", \"y\" or \"z\". origin is center of projection plane in the normal direction.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.readlog-Tuple{Any}","page":"API Reference","title":"Vlasiator.readlog","text":"readlog(file)\n\nRead the run log file, check the iteration status and return the timestamps (exluding the last) as well as the model running speed in physical seconds per simulated seconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readparameter-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.readparameter","text":"readparameter(meta, param)\n\nReturn the parameter value from vlsv file.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readvariable","page":"API Reference","title":"Vlasiator.readvariable","text":"readvariable(meta::MetaVLSV, var, sorted::Bool=true) -> Array\n\nReturn variable value of var from the vlsv file. By default sorted=true, which means that for DCCRG grid the variables are sorted by cell ID.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.readvariable-Tuple{MetaVLSV, Any, Any}","page":"API Reference","title":"Vlasiator.readvariable","text":"readvariable(meta::MetaVLSV, var, ids) -> Array\n\nRead a variable var in a collection of cells ids.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readvariablemeta-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.readvariablemeta","text":"readvariablemeta(meta, var) -> VarInfo\n\nReturn VarInfo about var in the vlsv file linked to meta.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readvcells-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.readvcells","text":"readvcells(meta, cid; species=\"proton\") -> vcellids, vcellf\n\nRead velocity cells from a spatial cell of ID cid, and return a map of velocity cell ids and corresponding value.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.refineslice-Tuple{MetaVLSV, Any, Any, Any}","page":"API Reference","title":"Vlasiator.refineslice","text":"refineslice(meta, idlist, data, normal) -> Array\n\nGenerate scalar data on the finest refinement level given cellids idlist and variable data on the slice perpendicular to normal.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.vdfslice","page":"API Reference","title":"Vlasiator.vdfslice","text":"vdfslice(meta, location, ax=nothing; kwargs...)\n\nPlot the 2D slice cut of phase space distribution function at location within velocity range limits. If ax===nothing, plot on the current active axes.\n\nOptional arguments\n\nunit::AxisUnit: location unit in SI, RE.\nunitv::String: velocity unit in (\"km/s\", \"m/s\").\nlimits::Vector{Real}: velocity space range given in [xmin, xmax, ymin, ymax].\nslicetype: symbol for choosing the slice type from :xy, :xz, :yz, :bperp, :bpar, :bpar1.\ncenter: symbol for setting the reference frame from :bulk, :peak.\nvslicethick: setting the velocity space slice thickness in the normal direction. If set\n\nto 0, the whole distribution along the normal direction is projected onto a plane. Currently this is only meaningful when center is set such that a range near the bulk/peak normal velocity is selected!\n\nfmin, fmax: minimum and maximum VDF values for plotting.\nweight::Symbol: choosing distribution weights from phase space density or particle flux\n\nbetween :particle and :flux.\n\nflimit: minimum VDF threshold for plotting.\nkwargs...: any valid keyword argument for hist2d.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.write_vlsv-Tuple{AbstractString, AbstractString, Vector{Tuple{VecOrMat, String, VarInfo}}}","page":"API Reference","title":"Vlasiator.write_vlsv","text":"write_vlsv(filein, fileout, newvars::Vector{Tuple{Vector, String, VarInfo}};\n   force=false)\n\nGenerate a new VLSV fileout based on filein, with newvars added. force=true overwrites the existing fileout.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.write_vtk-Tuple{MetaVLSV}","page":"API Reference","title":"Vlasiator.write_vtk","text":"write_vtk(meta::MetaVLSV; kwargs...)\nwrite_vtk(file; kwargs...)\n\nConvert VLSV file to VTK format.\n\nKeyword arguments\n\nvars=[\"\"]: select which variables to convert.\nascii=false: output stored in ASCII or compressed binary format.\nmaxamronly=false: generate image files on the highest refinement level only.\nverbose=false: display logs during conversion.\n\n\n\n\n\n","category":"method"},{"location":"internal/#PyPlot-helpers","page":"API Reference","title":"PyPlot helpers","text":"","category":"section"},{"location":"internal/","page":"API Reference","title":"API Reference","text":"Modules = [Vlasiator]\nPages   = [\"plot/pyplot.jl\"]","category":"page"},{"location":"internal/#Vlasiator.set_colorbar","page":"API Reference","title":"Vlasiator.set_colorbar","text":"set_colorbar(colorscale::ColorScale, v1, v2, data=[1.0]) -> cnorm, cticks\n\nSet colorbar norm and ticks in a given range v1 to v2 for data in colorscale. Matplotlib's Colormap Normalization Section presents various kinds of normlizations beyond linear, logarithmic and symmetric logarithmic, like centered, discrete, and two slope norm. For fine-grain control, it is suggested to use the norm methods from matplotlib.colors. For instance, \n\njulia> cnorm = matplotlib.colors.CenteredNorm(); # after matplotlib v3.4\njulia> cnorm = matplotlib.colors.BoundaryNorm(boundaries=[0, 1], ncolors=2);\njulia> cnorm = matplotlib.colors.TwoSlopeNorm(vmin=-500., vcenter=0, vmax=4000);\n\nThere are also various options for the ticks available in matplotlib.ticker.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.set_plot-Tuple{Any, Any, Vlasiator.PlotArgs, Any, Any}","page":"API Reference","title":"Vlasiator.set_plot","text":"Configure customized plot.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Private-APIs","page":"API Reference","title":"Private APIs","text":"","category":"section"},{"location":"internal/","page":"API Reference","title":"API Reference","text":"Modules = [Vlasiator]\nPublic = false","category":"page"},{"location":"internal/#Vlasiator.AxisUnit","page":"API Reference","title":"Vlasiator.AxisUnit","text":"Axis unit type. Currently supported: SI, RE.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Vlasiator.ColorScale","page":"API Reference","title":"Vlasiator.ColorScale","text":"Color scales type for 2D plots. Currently supported: Log, Linear, SymLog.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Vlasiator.PlotArgs","page":"API Reference","title":"Vlasiator.PlotArgs","text":"Plotting arguments.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Vlasiator.VMeshInfo","page":"API Reference","title":"Vlasiator.VMeshInfo","text":"Velocity mesh information.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Base.ndims-Tuple{MetaVLSV}","page":"API Reference","title":"Base.ndims","text":"ndims(meta) -> Int\n\nReturn the dimension of VLSV data.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.size-Tuple{MetaVLSV}","page":"API Reference","title":"Base.size","text":"File size in bytes.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.curl-Union{Tuple{N}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, N}}} where {T, N}","page":"API Reference","title":"Vlasiator.curl","text":"curl(dx::AbstractVector, A::AbstractArray)\n\nCalculate 2nd order cell-centered ∇×A where A is a 4D array of size (3, nx, ny, nz) and dx is a vector of grid intervals in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.fillmesh-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.fillmesh","text":"fillmesh(meta::MetaVLSV, vars; verbose=false) -> celldata, vtkGhostType\n\nFill the DCCRG mesh with quantity of vars on all refinement levels.\n\nReturn arguments\n\ncelldata::Vector{Vector{Array}}: data for each variable on each AMR level.\nvtkGhostType::Array{UInt8}: cell status (to be completed!).\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.flatten-Tuple{Vlasiator.VMeshInfo, Any, Any}","page":"API Reference","title":"Vlasiator.flatten","text":"flatten(vmesh::VMeshInfo, vcellids, vcellf)\n\nFlatten vblock-organized VDFs into x–>y–>z ordered 3D VDFs. vcellids are local indices of nonzero VDFs and vcellf are their corresponding values.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.get1stcell-Tuple{Any, Any}","page":"API Reference","title":"Vlasiator.get1stcell","text":"Return the first cellid - 1 on mylevel given ncells on this level.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getObjInfo-NTuple{4, Any}","page":"API Reference","title":"Vlasiator.getObjInfo","text":"Return size and type information for the object.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getRotationMatrix-Tuple{AbstractVector, Any}","page":"API Reference","title":"Vlasiator.getRotationMatrix","text":"getRotationMatrix(axis, angle) --> SMatrix{3,3}\n\nCreate a rotation matrix for rotating a 3D vector around a unit axis by an angle in radians. Reference: https://en.wikipedia.org/wiki/Rotationmatrix#Rotationmatrixfromaxisandangle\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.get_axis-Tuple{Vlasiator.AxisUnit, Any, Any}","page":"API Reference","title":"Vlasiator.get_axis","text":"Return x and y ranges for 2D.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getdata2d-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.getdata2d","text":"Return 2d scalar/vector data. Nonpublic because it won't work with DCCRG AMR.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getfooter-Tuple{IOStream}","page":"API Reference","title":"Vlasiator.getfooter","text":"Return the xml footer of vlsv.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.getindexes-NTuple{5, Any}","page":"API Reference","title":"Vlasiator.getindexes","text":"Compute every cell id's x, y and z indexes on the given refinement level (0-based).\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.prep2d","page":"API Reference","title":"Vlasiator.prep2d","text":"prep2d(meta, var, op=:none) -> Array\n\nObtain data from meta of var for 2D plotting. Use op to select vector components.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.prep2dslice-Tuple{MetaVLSV, Any, Any, Any, Vlasiator.PlotArgs}","page":"API Reference","title":"Vlasiator.prep2dslice","text":"prep2dslice(meta::MetaVLSV, var, normal, op, pArgs::PlotArgs)\n\nReturn data of var on a uniform 2D mesh on the finest AMR level. Use normal to select the plane orientation, and op to select the component of a vector, same as in pcolormeshslice.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.prep_vdf-Tuple{MetaVLSV, Any}","page":"API Reference","title":"Vlasiator.prep_vdf","text":"prep_vdf(meta::MetaVLSV, location; kwargs...)\n\nReturn the cell velocities v1, v2, bin ranges r1, r2, cell VDF values fweight, and strings of labels and titles for VDF plots.\n\nOptional arguments\n\nunit::AxisUnit: location unit in SI, RE.\nunitv::String: velocity unit in (\"km/s\", \"m/s\").\nlimits::Vector{Real}: velocity space range given in [xmin, xmax, ymin, ymax].\nslicetype: symbol for choosing the slice type from :xy, :xz, :yz, :bperp, :bpar, :bpar1.\ncenter: symbol for setting the reference frame from :bulk, :peak.\nvslicethick: setting the velocity space slice thickness in the normal direction. If set\n\nto 0, the whole distribution along the normal direction is projected onto a plane. Currently this is only meaningful when center is set such that a range near the bulk/peak normal velocity is selected!\n\nweight::Symbol: choosing distribution weights from phase space density or particle flux\n\nbetween :particle and :flux.\n\nflimit: minimum VDF threshold for plotting.\nverbose: display the selection process.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readmesh-Tuple{IOStream, Any, Any, Any}","page":"API Reference","title":"Vlasiator.readmesh","text":"Return mesh related variable.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.readvector-Tuple{IOStream, Any, Any, Any}","page":"API Reference","title":"Vlasiator.readvector","text":"Return vectors of name from the vlsv file with footer opened by fid.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.rotateTensorToVectorZ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T","page":"API Reference","title":"Vlasiator.rotateTensorToVectorZ","text":"rotateTensorToVectorZ(tensor, vector)\n\nRotate tensor with a rotation matrix that aligns the 3rd direction with vector, which is equivalent to change the basis from (i,j,k) to (i′,j′,k′) where k′ ∥ vector. Reference: https://math.stackexchange.com/questions/2303869/tensor-rotation\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.save_image","page":"API Reference","title":"Vlasiator.save_image","text":"save_image(meta::MetaVLSV, file, vars, data, vtkGhostType, level,\n   ascii=false, append=true)\n\nSave data of name vars at AMR level into VTK image file of name file.\n\nArguments\n\nfile::String: output file name.\nvars::Vector{String}: variable names to be saved.\ndata::Vector{Vector}: data for all the variables on each refinement level.\nvtkGhostType::Array{UInt8}: array for visibility control.\nlevel::Int: refinement level (0-based).\nascii=false: save output in ASCII or binary format.\nappend=true: determines whether to append data at the end of file or do in-block writing.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Vlasiator.set_args-Tuple{MetaVLSV, Any, Vlasiator.AxisUnit}","page":"API Reference","title":"Vlasiator.set_args","text":"set_args(meta::MetaVLSV, var, axisunit::AxisUnit; normal::Symbol=:none, origin=0.0)\n\nSet plot-related arguments of var in axisunit. normal and origin are used for 2D slices of 3D data, as specified in pcolormeshslice.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Vlasiator.set_lim","page":"API Reference","title":"Vlasiator.set_lim","text":"set_lim(vmin, vmax, data, colorscale=Linear)\n\nSet colormap limits vmin, vmax for data under scale colorscale.\n\n\n\n\n\n","category":"function"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/#PyPlot","page":"Gallery","title":"PyPlot","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton density in advection flow with points denoting cell centers","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton density of Earth's magnetosphere in the meridional plane from 3D simulation","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton density of Earth's magnetosphere in the equatorial plane from 2D simulation, zoomed in to the magnetosheath and foreshock region, with streamlines and density contour at 1e7","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton density of Earth's magnetosphere in the meridional cut from 2D simulation, with fieldlines through fixed seeding points","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton density of Earth's magnetosphere in the normal cut planes from 3D simulation","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton phase space distribution projected onto xz plane","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/#Makie","page":"Gallery","title":"Makie","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Interactive proton density slice from 3D AMR run","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton phase space distribution projected onto xz plane","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Interactive proton phase space distribution projected onto three orthogonal planes","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Proton phase space distribution","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/#ParaView","page":"Gallery","title":"ParaView","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"2D slice contour of density in meriodional plane with streamlines","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"2D slices of density viewing from upstream","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: )","category":"page"},{"location":"log/#Log","page":"Log","title":"Log","text":"","category":"section"},{"location":"log/#Test-Data","page":"Log","title":"Test Data","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"If you don't have VLSV data at hand, Vlasiator.jl provides some test data for you to begin with.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"using LazyArtifacts\n\nrootpath = artifact\"testdata\"\nfiles = joinpath.(rootpath, (\"bulk.1d.vlsv\", \"bulk.2d.vlsv\", \"bulk.amr.vlsv\"))","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"These are also used in the standard test. These will be automatically downloaded from vlsv_data if you run the package test locally.","category":"page"},{"location":"log/#Performance","page":"Log","title":"Performance","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"The VLSV loader inherits the basic structure from Analysator and is redesigned for performance.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Besides the language difference in speed, one of the key decisions in boosting performance is to avoid the usage of dictionary with integer keys as much as possible.\nIt is generally faster to read a bunch of cell IDs together than to read each cell one-by-one.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"For development, it is recommended to use PkgBenchmark.jl to run the test suite:","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"using PkgBenchmark, Vlasiator\nresults = benchmarkpkg(Vlasiator)","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"or if you want to compare the current status of the package against a different git version","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"judge(Vlasiator, \"97e3dca6b2474d7bdc5b62b5bf98ecf070516e5e\")","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"To export results to markdown format,","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"export_markdown(\"testresult\", results)","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"See more in the PkgBenchmark manual.","category":"page"},{"location":"log/#Benchmarks","page":"Log","title":"Benchmarks","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"note: Note\nThe numbers shown here are comparisons between Analysator v0.9 and Vlasiator.jl v0.8.26 running Python 3.6.9 and Julia 1.6.3. The timings are performed on a i5-10210U @ 1.6GHz if not specified. Keep in mind that when we are comparing against Python, we are mostly likely comparing with the underlying C libraries with a Python wrapper.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Reading DCCRG grid variables","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Variable[1] 80KB Float32 900KB Float64 32MB Float64\nJulia  [ms] 0.2 5.9 303[2]\nPython [ms] 2.2 10 295","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"[1]: The size here represents the actual size of the variable, not the total file size. The larger the data sizes, the less meaningful in these comparisons since the time is dominant by low level I/O, where in Python it's written in C.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"[2]: Julia is slower for this test because there is a conversion from Float64 to Float32. See Precision.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Reading field solver grid variables[3]","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"13 GB tmean [s]\nJulia 8\nPython 61","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"[3]: The field solver grid is a regular Cartesian grid at the finest refinement level. Therefore the storage requirement for fsgrid variables are quite significant: with 16 GB memory it is barely enough to read fg_b once. It will go out of memory for the second time in Analysator, but not in Vlasiator.jl –- see Memory. This reading time corresponds to 35% of the maximum sequential read speed on the target machine.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"From starting Julia/Python to the first plot of 2D density contour[4]","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"28 MB tmean [s]\nJulia 1.6 11.6\nPython 3.6 9.4","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"[4]: This inefficieny of Julia is a famous problem in the community known as \"time to first plot\". On the Python side, however, I don't know why using Analysator is slower (2.3GB file, 4.8s) than directly calling matplotlib functions (2.3GB file, 0.5s).","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Reading and plotting one 2d slice of proton density out of 3D AMR data","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"32 MB tmean [s]\nJulia 0.35\nPython 1.7","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"Virtual satellite tracking from 200 frames of 3D AMR data (26G per frame, 32 MB Cell IDs) on a cluster","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"1 core tmean [s][5]\nJulia 239\nPython 376","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"[5]: The timings include importing the libraries, extracting the data and saving to text files using a single CPU on Vorna, a local cluster at University of Helsinki with Intel Xeon E5-2697 @ 2.70GHz. With multithreading, the Julia timings can scale linearly on a node with the number of cores used.","category":"page"},{"location":"log/#Precision","page":"Log","title":"Precision","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"For post-processing and data analysis purposes, it makes less sense to stick to double precisions, so we mostly use Float32 in Vlasiator.jl. Several exceptions are:","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"physical constants are defined in Float64, since single precision only resolve up to ±3.4E+38, and it may go out of bound in the middle of calculation (e.g. plasma frequency).","category":"page"},{"location":"log/#Memory","page":"Log","title":"Memory","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"Vlasiator output files can be large. If we have limited memory relative to the file size, Vlasiator.jl provide direct hard disk mapping through mmap in Julia. With this mechanism you never need to worry about unable to process data with small free memory.","category":"page"},{"location":"log/#Parallelism","page":"Log","title":"Parallelism","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"The current design choice is to achieve optimal serial performance per file, and apply parallel processing across individual files. In most common cases, the time it takes for post-processing one snapshot is reasonably short, but the number of snapshots are large. Julia's built-in support for all kinds of parallelism paradigm (multithreads, multiprocess, channel) and external support from packages (MPI.jl, Polyester.jl) can be relatively easily incorported to make the whole workflow parallel.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"In the examples, you can find the usages of","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"multi-threading with @threads (recommended when working within one node)\nmulti-processing with pmap \nmulti-processing with RemoteChannel\nClusterManagers for multi-node jobs","category":"page"},{"location":"log/#VTK","page":"Log","title":"VTK","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"VLSV is just an uncompressed binary format. If we convert VLSV to VTK through write_vtk, the generated VTK files, even the highest resolution one with every coarse cell mapping to the finest level, can be several times smaller than the original VLSV file.","category":"page"},{"location":"log/","page":"Log","title":"Log","text":"One drawback of this conversion is that it cannot deal with phase space outputs, i.e. VDFs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Vlasiator","category":"page"},{"location":"#Vlasiator.jl","page":"Home","title":"Vlasiator.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Data processing and analyzing tool for the numerical model for collisionless ion-kinetic plasma physics Vlasiator. This lightweight package is built upon its sister in Python Analysator and carefully designed for performance, capability and ease of use. It can be easily integrated with external packages like FieldTracer.jl and TestParticle.jl to do all kinds of in-depth analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Vlasiator.jl contains the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reading VLSV format data.\nCalculating derived quantities from VLSV outputs.\nExtracting quantities at a given point/line/plane.\nPlotting 1D curves/2D cuts of saved/derived variables, and phase space distributions.\nConverting VLSV into VTK format for postprocessing in e.g. ParaView and VisIt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package mostly aims at supporting Vlasiator 5.0+. Older versions of Vlasiator has different naming standard for outputs, and is not guaranteed to work. This analysator wiki page describes the old and new naming standards in detail.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install,","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Vlasiator","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then get started with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Vlasiator","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to use Plots.jl for visualization, add it also through the pkg manager; if you aim at using Matplotlib, besides adding PyPlot, you should also link to a preinstalled Python version by setting the environment variable and building the PyCall package","category":"page"},{"location":"","page":"Home","title":"Home","text":"ENV[\"PYTHON\"]=\"your python executable\"\nPkg.build(\"PyCall\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details are described in automated matplotlib installation.","category":"page"},{"location":"#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module is written by Hongyang Zhou.","category":"page"}]
}
